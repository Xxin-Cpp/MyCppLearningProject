析构函数（destructor）

 它和构造函数有相似之处，构造函数在你创建一个对象实例的时候运行，而构析函数是在你销毁一个对象的时候运行，在任何时候，当一个对象被销毁的时候，析构函数都会被调用。

析构函数通常用在你需要设置变量或者做些初始化工作的时候，同样的，析构函数可以用在你释放任何内容或者需要清理内存空间的时候，析构函数同事适用于栈和堆分配的内存，如果你只有基于栈的对象，当跳出作用域的时候这个对象会被删除，所以这时候析构函数也会被调用。



如何写析构函数 析构函数前面有个波形符号（~）然后是类名。

```c++
	~Entity()
	{
		  
	}
```

总的来说，构造和析构函数在声明和定义的唯一区别就是，放在析构函数前面的这个波形符号

Cpp中有一个包含两个成员X和Y类，很明显当我们为这两个浮点数申请内存的时候并没有考虑怎样去清除

```
#include <iostream>

class Entity
{

public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f; 
		std::cout << "Constructed Entity" << std::endl;
	}


	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl; 
	}
	void Print() {
		std::cout << X << "," << Y << std::endl;
	}

};

class Log
{
public:
	static void Write()
	{

	}
};

void Function()
{
	Entity e;
	e.Print();
}

int main() { 
	Function();
	std::cin.get();
}
```

为什么要这么写？因为如果不写进Function，**如果在main直接调用，析构方法将会在main函数结束之后调用，我们就看不到了**



本质来讲，析构函数就是在一个对象销毁时会被调用的特殊的函数和方法，在实际工作我们为什么要写析构函数呢？那就是如果在构造函数中做了一些初始化工作，你看会想要在析构函数里进行释放或者销毁工作，如果不这么做的话，就可能会造成内存泄漏，一个很好的例子就是堆分配对象，如果你手动在堆上分配了任何类型的内存空间，那么你也要手动地进行清除。

如果在使用Entity或者在Entity的构造函数中进行的分配，那么你就要在构析函数中清除它们，因为析构函数调用后，那个Entity对象就不存在了，你也可以手动调用析构函数，但是如果真这样做了又会有点奇怪。唯一这样做到原因是使用new来进行内存分配，当删除它时，用free函数之类的东西，然后手动调用析构函数。还是可以像调用其他函数一样使用 `e.~Entiuty();`来调用析构函数，不建议这么写，